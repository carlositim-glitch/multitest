from fastapi import FastAPI, UploadFile, File, HTTPException, Form
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
import os
import json
import shutil
from pathlib import Path
import re
import gc
import fitz  # PyMuPDF
from PIL import Image
import io
import base64
import requests
import time

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

UPLOAD_DIR = Path("uploads")
RESULT_DIR = Path("../resultados")
TEMP_DIR = Path("temp_chunks")
UPLOAD_DIR.mkdir(exist_ok=True)
RESULT_DIR.mkdir(exist_ok=True)
TEMP_DIR.mkdir(exist_ok=True)

# API Key gratuita de OCR.space (25,000 requests/mes)
OCR_API_KEY = "K87899142388957"  # Key p√∫blica de ejemplo, puedes obtener la tuya en ocr.space

print(f"\n{'='*60}")
print(f"‚òÅÔ∏è  Sistema OCR Cloud - SIN INSTALACIONES")
print(f"‚úÖ Usa OCR.space API (gratuita)")
print(f"‚úÖ No requiere instalar nada en el sistema")
print(f"‚úÖ Funciona en Windows/Linux/Mac")
print(f"{'='*60}\n")


def limpiar_caracteres_especiales(texto: str) -> str:
    """Limpia caracteres especiales"""
    texto = texto.replace('"', '"')
    texto = texto.replace('"', '"')
    texto = texto.replace('¬´', '"')
    texto = texto.replace('¬ª', '"')
    texto = texto.replace(''', "'")
    texto = texto.replace(''', "'")
    texto = texto.replace('‚Äì', '-')
    texto = texto.replace('‚Äî', '-')
    texto = texto.replace('\xa0', ' ')
    texto = texto.replace('\u200b', '')
    texto = texto.replace('N?', 'N¬∫')
    texto = texto.replace('N¬∞', 'N¬∫')
    return texto


def unir_palabras_divididas_optimizado(texto: str) -> str:
    """Une palabras divididas por guiones"""
    lineas = texto.split('\n')
    resultado = []
    
    i = 0
    while i < len(lineas):
        linea_actual = lineas[i]
        
        if i < len(lineas) - 1 and re.search(r'[a-z√°√©√≠√≥√∫√±]\-\s*$', linea_actual, re.IGNORECASE):
            linea_siguiente = lineas[i + 1].strip()
            
            if re.match(r'^[a-z√°√©√≠√≥√∫√±]', linea_siguiente, re.IGNORECASE):
                linea_actual = re.sub(r'\-\s*$', '', linea_actual)
                linea_actual += linea_siguiente
                i += 1
        
        resultado.append(linea_actual)
        i += 1
    
    return '\n'.join(resultado)


def limpiar_texto_avanzado(texto: str) -> str:
    """Limpieza del texto extra√≠do por OCR"""
    patrones_eliminar_bloques = [
        r'En la direcci√≥n https?://[^\n]*\n?',
        r'puede ser comprobada la autenticidad[^\n]*\n?',
        r'documento electr√≥nico siguiente[^\n]*\n?',
        r'Convocatoria:\s*PROCESOS SELECTIVOS[^\n]*\n?',
        r'Categor√≠a:\s*GRUPO ADMINISTRATIVO[^\n]*\n?',
        r'N¬∫ de preguntas de reserva:\s*\d+\n?',
        r'N\? de preguntas de reserva:\s*\d+\n?',
        r'Listado de preguntas definitivo[^\n]*\n?',
        r'P√°gina\s+\d+\s+de\s+\d+\s*\n?',
        r'Servicio\s*\n?Canario de la Salud\s*\n?',
        r'Gobierno\s*\n?de Canarias\s*\n?',
        r'^[0-9a-zA-Z]{40,}\s*$',
        r'Fecha:\s*\d{2}/\d{2}/\d{4}\s*-\s*\d{2}:\d{2}:\d{2}\s*\n?',
    ]
    
    texto_limpio = texto
    
    for patron in patrones_eliminar_bloques:
        texto_limpio = re.sub(patron, '', texto_limpio, flags=re.MULTILINE | re.IGNORECASE)
    
    texto_limpio = re.sub(r'\n{3,}', '\n\n', texto_limpio)
    texto_limpio = re.sub(r' {2,}', ' ', texto_limpio)
    
    texto_limpio = limpiar_caracteres_especiales(texto_limpio)
    texto_limpio = unir_palabras_divididas_optimizado(texto_limpio)
    
    return texto_limpio


def ocr_con_api(image_bytes: bytes, retries=3) -> str:
    """
    Usa OCR.space API para extraer texto de una imagen
    API gratuita: 25,000 requests/mes
    """
    url = "https://api.ocr.space/parse/image"
    
    for attempt in range(retries):
        try:
            # Preparar imagen
            files = {
                'file': ('image.png', image_bytes, 'image/png')
            }
            
            payload = {
                'apikey': OCR_API_KEY,
                'language': 'spa',  # Espa√±ol
                'isOverlayRequired': False,
                'detectOrientation': True,
                'scale': True,
                'OCREngine': 2  # Engine 2 es mejor para espa√±ol
            }
            
            response = requests.post(url, files=files, data=payload, timeout=60)
            result = response.json()
            
            if result.get('IsErroredOnProcessing'):
                print(f"   ‚ö†Ô∏è  Error API: {result.get('ErrorMessage', 'Unknown')}")
                if attempt < retries - 1:
                    time.sleep(2)
                    continue
                return ""
            
            # Extraer texto
            parsed_results = result.get('ParsedResults', [])
            if parsed_results:
                texto = parsed_results[0].get('ParsedText', '')
                return texto
            
            return ""
            
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Error en intento {attempt + 1}: {str(e)}")
            if attempt < retries - 1:
                time.sleep(2)
            else:
                return ""
    
    return ""


def extraer_chunk_pdf_con_ocr_api(pdf_path, inicio_pagina, fin_pagina):
    """
    Extrae texto de un rango espec√≠fico de p√°ginas usando OCR.space API
    """
    try:
        doc = fitz.open(pdf_path)
        texto_chunks = []
        
        for page_num in range(inicio_pagina, min(fin_pagina, len(doc))):
            page = doc[page_num]
            
            # Primero intentar extraer texto normal
            texto_normal = page.get_text()
            
            if texto_normal and len(texto_normal.strip()) > 100:
                texto_chunks.append(texto_normal)
                print(f"   üìÑ P√°gina {page_num + 1}: Texto directo")
            else:
                # Usar OCR API
                print(f"   üîç P√°gina {page_num + 1}: Usando OCR API...")
                
                # Convertir p√°gina a imagen PNG
                mat = fitz.Matrix(2, 2)
                pix = page.get_pixmap(matrix=mat)
                img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                
                # Convertir a bytes PNG
                img_byte_arr = io.BytesIO()
                img.save(img_byte_arr, format='PNG')
                img_bytes = img_byte_arr.getvalue()
                
                # Llamar a la API
                texto_ocr = ocr_con_api(img_bytes)
                
                if texto_ocr:
                    texto_chunks.append(texto_ocr)
                    print(f"   ‚úÖ Extra√≠dos {len(texto_ocr)} caracteres")
                else:
                    print(f"   ‚ö†Ô∏è  No se pudo extraer texto")
                
                # Pausa para no saturar la API gratuita
                time.sleep(1)
        
        doc.close()
        
        texto = '\n'.join(texto_chunks)
        texto_limpio = limpiar_texto_avanzado(texto)
        
        return texto_limpio
        
    except Exception as e:
        raise Exception(f"Error extrayendo chunk {inicio_pagina}-{fin_pagina}: {str(e)}")


def encontrar_candidatos_pregunta(texto: str) -> list:
    """Encuentra TODOS los candidatos que PODR√çAN ser preguntas"""
    lineas = texto.split('\n')
    candidatos = []
    
    for i, linea in enumerate(lineas):
        linea_strip = linea.strip()
        match = re.match(r'^(\d+)[\.\)\-]+\s*(.+)', linea_strip)
        
        if match:
            numero = int(match.group(1))
            texto_despues = match.group(2).strip()
            
            if 1 <= numero <= 600:
                if not re.match(r'^\d+\s', texto_despues):
                    if len(texto_despues) > 0 or (i + 1 < len(lineas) and len(lineas[i+1].strip()) > 0):
                        candidatos.append({
                            'linea': i,
                            'numero': numero,
                            'texto': linea_strip[:150]
                        })
    
    return candidatos


def seleccionar_preguntas_en_secuencia(candidatos: list, lineas: list, numero_inicio: int = 1) -> list:
    """Selecciona preguntas permitiendo saltos si faltan n√∫meros"""
    preguntas_seleccionadas = []
    numero_esperado = numero_inicio
    ultima_linea = -1
    saltos_consecutivos = 0
    MAX_SALTOS = 5  # M√°ximo de n√∫meros que puede saltar antes de rendirse
    
    while numero_esperado <= 1000:
        candidatos_numero = [
            c for c in candidatos 
            if c['numero'] == numero_esperado and c['linea'] > ultima_linea
        ]
        
        if not candidatos_numero:
            # No encontr√≥ este n√∫mero, intentar con el siguiente
            saltos_consecutivos += 1
            if saltos_consecutivos >= MAX_SALTOS:
                # Buscar el pr√≥ximo n√∫mero disponible
                candidatos_disponibles = [c for c in candidatos if c['numero'] > numero_esperado]
                if candidatos_disponibles:
                    siguiente_disponible = min(c['numero'] for c in candidatos_disponibles)
                    print(f"   ‚ö†Ô∏è  Saltando de #{numero_esperado} a #{siguiente_disponible}")
                    numero_esperado = siguiente_disponible
                    saltos_consecutivos = 0
                    continue
                else:
                    break
            numero_esperado += 1
            continue
        
        saltos_consecutivos = 0  # Reset al encontrar una
        
        # Resto del c√≥digo igual...

def extraer_bloque_pregunta(lineas: list, inicio: int, fin: int) -> str:
    """Extrae TODO entre dos preguntas"""
    bloque = []
    
    for i in range(inicio, min(fin, len(lineas))):
        linea = lineas[i].strip()
        
        if len(linea) == 0:
            continue
        if re.match(r'^[0-9a-zA-Z_]{40,}$', linea):
            continue
        
        bloque.append(linea)
    
    return '\n'.join(bloque)


def extraer_enunciado(lineas: list, inicio: int) -> str:
    """Extrae enunciado de la pregunta"""
    primera_linea = lineas[inicio].strip()
    match = re.match(r'^\d+[\.\)\-]+\s*(.+)', primera_linea)
    enunciado = match.group(1) if match else primera_linea
    
    i = inicio + 1
    while i < min(len(lineas), inicio + 25):
        linea = lineas[i].strip()
        
        if re.match(r'^[A-Da-d][\.\)\-\s]+', linea):
            break
        
        if len(linea) > 2:
            enunciado += " " + linea
        
        i += 1
    
    return re.sub(r'\s+', ' ', enunciado).strip()


def extraer_opciones(bloque: str, numero_pregunta: int) -> dict:
    """Extrae opciones A, B, C, D"""
    lineas = bloque.split('\n')
    opciones = {}
    
    for letra in ['A', 'B', 'C', 'D']:
        opcion_encontrada = None
        
        for i, linea in enumerate(lineas):
            match = re.match(rf'^{letra}[\.\)\-\s]+(.*)$', linea.strip(), re.IGNORECASE)
            
            if match:
                texto_capturado = match.group(1).strip()
                texto_completo = [texto_capturado] if texto_capturado else []
                j = i + 1
                
                while j < len(lineas):
                    siguiente = lineas[j].strip()
                    
                    if re.match(r'^[A-Da-d][\.\)\-\s]+', siguiente):
                        break
                    if re.search(r'Respuesta\s+Correcta', siguiente, re.IGNORECASE):
                        break
                    
                    if len(siguiente) > 0:
                        texto_completo.append(siguiente)
                    
                    j += 1
                    
                    if j - i > 15:
                        break
                
                if texto_completo:
                    opcion_texto = ' '.join(texto_completo)
                    opcion_texto = re.sub(r'\s*Respuesta\s+Correcta.*$', '', opcion_texto, flags=re.IGNORECASE)
                    opcion_texto = re.sub(r'\s+', ' ', opcion_texto).strip()
                    
                    if len(opcion_texto) > 0:
                        opcion_encontrada = opcion_texto
                        break
        
        opciones[letra] = opcion_encontrada if opcion_encontrada else "[FALTA - NO ENCONTRADA]"
    
    return opciones


def extraer_respuesta_correcta(bloque: str) -> str:
    """Extrae respuesta correcta"""
    patrones = [
        r'Respuesta\s+[Cc]orrecta\s*:\s*([A-D])',
        r'Correcta\s*:\s*([A-D])',
        r'RC\s*:\s*([A-D])',
    ]
    
    for patron in patrones:
        match = re.search(patron, bloque, re.IGNORECASE)
        if match:
            return match.group(1).upper()
    
    return "?"


def procesar_pregunta(lineas: list, pos_actual: dict, pos_siguiente: dict, numero_real: int) -> dict:
    """Procesa una pregunta"""
    linea_inicio = pos_actual['linea']
    linea_fin = pos_siguiente['linea'] if pos_siguiente else len(lineas)
    
    enunciado = extraer_enunciado(lineas, linea_inicio)
    bloque = extraer_bloque_pregunta(lineas, linea_inicio, linea_fin)
    opciones = extraer_opciones(bloque, numero_real)
    respuesta = extraer_respuesta_correcta(bloque)
    
    resultado = {
        'id': numero_real,
        'pregunta': enunciado,
        'opciones': opciones,
        'respuestaCorrecta': respuesta
    }
    
    advertencias = []
    for letra in ['A', 'B', 'C', 'D']:
        if opciones[letra] == "[FALTA - NO ENCONTRADA]":
            advertencias.append(f"Opci√≥n {letra} no encontrada")
    
    if advertencias:
        resultado['_ADVERTENCIA'] = {
            'problemas': advertencias,
            'linea_inicio': linea_inicio + 1,
            'accion': 'Revisar manualmente en el PDF'
        }
    
    return resultado


def extraer_preguntas_del_chunk(texto: str, numero_inicio_esperado: int) -> list:
    """Extrae preguntas de un chunk de texto"""
    lineas = texto.split('\n')
    candidatos = encontrar_candidatos_pregunta(texto)
    
    print(f"   üîé Candidatos encontrados: {len(candidatos)}")
    
    posiciones = seleccionar_preguntas_en_secuencia(candidatos, lineas, numero_inicio_esperado)
    
    print(f"   ‚úÖ Preguntas seleccionadas: {len(posiciones)}")
    
    if len(posiciones) == 0:
        return []
    
    preguntas = []
    
    for i, pos in enumerate(posiciones):
        pos_siguiente = posiciones[i + 1] if i + 1 < len(posiciones) else None
        numero_secuencia = pos['numero']
        
        pregunta = procesar_pregunta(lineas, pos, pos_siguiente, numero_secuencia)
        preguntas.append(pregunta)
    
    return preguntas


def procesar_pdf_por_chunks_ocr_api(pdf_path, chunk_size=3):
    """
    Procesa el PDF escaneado en chunks con guardado incremental
    """
    try:
        doc = fitz.open(pdf_path)
        total_paginas = len(doc)
        doc.close()
        
        print(f"\n{'='*60}")
        print(f"üìñ PROCESAMIENTO OCR API POR CHUNKS: {pdf_path}")
        print(f"üì¶ Tama√±o de chunk: {chunk_size} p√°ginas")
        print(f"üìö Total de p√°ginas: {total_paginas}")
        print(f"{'='*60}")
        
        # Archivo de salida final
        nombre_json = Path(pdf_path).stem + '.json'
        resultado_path = RESULT_DIR / nombre_json
        
        todas_preguntas = []
        numero_pregunta_esperado = 1
        
        for chunk_idx in range(0, total_paginas, chunk_size):
            chunk_end = min(chunk_idx + chunk_size, total_paginas)
            chunk_num = (chunk_idx // chunk_size) + 1
            
            print(f"\n{'='*60}")
            print(f"üìÑ CHUNK {chunk_num}: P√°ginas {chunk_idx + 1}-{chunk_end}")
            print(f"{'='*60}")
            
            texto_chunk = extraer_chunk_pdf_con_ocr_api(pdf_path, chunk_idx, chunk_end)
            
            print(f"   üìù Texto extra√≠do: {len(texto_chunk):,} caracteres")
            
            if len(texto_chunk) < 50:
                print(f"   ‚ö†Ô∏è  Chunk con muy poco texto - saltando")
                del texto_chunk
                gc.collect()
                continue
            
            print(f"   üîç Buscando preguntas desde #{numero_pregunta_esperado}...")
            
            lineas = texto_chunk.split('\n')
            candidatos = encontrar_candidatos_pregunta(texto_chunk)
            
            print(f"   üîé Candidatos encontrados: {len(candidatos)}")
            
            # DEBUG: Mostrar qu√© n√∫meros se encontraron
            if candidatos:
                numeros_encontrados = [c['numero'] for c in candidatos]
                print(f"   üìã N√∫meros detectados: {numeros_encontrados}")
            
            posiciones = seleccionar_preguntas_en_secuencia(candidatos, lineas, numero_pregunta_esperado)
            
            print(f"   ‚úÖ Preguntas seleccionadas: {len(posiciones)}")
            
            if len(posiciones) > 0:
                # Procesar preguntas
                preguntas_chunk = []
                for i, pos in enumerate(posiciones):
                    pos_siguiente = posiciones[i + 1] if i + 1 < len(posiciones) else None
                    numero_secuencia = pos['numero']
                    
                    pregunta = procesar_pregunta(lineas, pos, pos_siguiente, numero_secuencia)
                    preguntas_chunk.append(pregunta)
                
                # A√±adir a la lista total
                todas_preguntas.extend(preguntas_chunk)
                
                ultima_pregunta = preguntas_chunk[-1]['id']
                numero_pregunta_esperado = ultima_pregunta + 1
                
                print(f"   üíæ {len(preguntas_chunk)} preguntas extra√≠das")
                print(f"   ‚û°Ô∏è  Siguiente esperado: #{numero_pregunta_esperado}")
                
                # GUARDAR PROGRESO cada chunk
                with open(resultado_path, 'w', encoding='utf-8') as f:
                    json.dump(todas_preguntas, f, ensure_ascii=False, indent=2)
                print(f"   üíæ Guardadas {len(todas_preguntas)} preguntas totales")
                
                del preguntas_chunk
            else:
                print(f"   ‚ö†Ô∏è  No se encontraron preguntas en secuencia")
                if candidatos:
                    print(f"   üí° Posible causa: Los n√∫meros {numeros_encontrados[:5]} no empiezan en #{numero_pregunta_esperado}")
            
            # LIBERAR MEMORIA AGRESIVAMENTE
            del texto_chunk
            del lineas
            del candidatos
            del posiciones
            gc.collect()
        
        total = len(todas_preguntas)
        con_advertencias = sum(1 for p in todas_preguntas if '_ADVERTENCIA' in p)
        
        print(f"\n{'='*60}")
        print(f"üìä ESTAD√çSTICAS FINALES")
        print(f"‚úÖ Total preguntas: {total}")
        print(f"‚ö†Ô∏è  Con advertencias: {con_advertencias}")
        print(f"‚ú® Perfectas: {total - con_advertencias}")
        if total > 0:
            print(f"üìà Tasa de √©xito: {100 * (total - con_advertencias) / total:.2f}%")
        print(f"{'='*60}")
        
        return todas_preguntas
        
    except Exception as e:
        raise Exception(f"Error en procesamiento OCR API por chunks: {str(e)}")
@app.post("/procesar-pdf")
async def procesar_pdf(file: UploadFile = File(...), workers: int = Form(1)):
    try:
        print(f"\n{'='*60}")
        print(f"üìÑ Procesando: {file.filename}")
        print(f"‚è±Ô∏è  Modo: OCR API CLOUD")
        print(f"{'='*60}")
        
        file_path = UPLOAD_DIR / file.filename
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        
        preguntas = procesar_pdf_por_chunks_ocr_api(file_path, chunk_size=3)
        
        nombre_json = file.filename.replace('.pdf', '.json')
        resultado_path = RESULT_DIR / nombre_json
        
        with open(resultado_path, 'w', encoding='utf-8') as f:
            json.dump(preguntas, f, ensure_ascii=False, indent=2)
        
        print(f"\nüíæ Resultado guardado: {nombre_json}")
        
        file_path.unlink()
        
        con_advertencias = sum(1 for p in preguntas if '_ADVERTENCIA' in p)
        
        return {
            "status": "success",
            "archivo": nombre_json,
            "preguntas_encontradas": len(preguntas),
            "preguntas_perfectas": len(preguntas) - con_advertencias,
            "preguntas_revisar": con_advertencias
        }
        
    except Exception as e:
        print(f"\n‚ùå ERROR: {str(e)}\n")
        import traceback
        traceback.print_exc()
        return {"status": "error", "message": str(e)}


@app.get("/")
async def read_root():
    return {"message": "Sistema OCR Cloud activo - Sin instalaciones"}


@app.get("/descargar/{filename}")
async def descargar_json(filename: str):
    file_path = RESULT_DIR / filename
    if file_path.exists():
        return FileResponse(file_path, filename=filename)
    raise HTTPException(status_code=404, detail="No encontrado")


if __name__ == "__main__":
    import uvicorn
    print("\nüöÄ Iniciando servidor OCR Cloud...")
    print("üì° http://localhost:8000")
    print("‚òÅÔ∏è  Usa OCR.space API (gratuita, 25k requests/mes)")
    print("‚úÖ NO requiere instalaciones del sistema\n")
    uvicorn.run(app, host="0.0.0.0", port=8000)
